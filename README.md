<!---
{
  "id": "81f2e303-d35c-4857-9cb7-190e3c5372b0",
  "depends_on": [
    "718193ef-11a1-408d-af23-4b10c24d490d",
    "99787eda-617a-4a68-b9a4-d60ec5c5c303",
    "302c98a7-cbea-435c-ada2-bbf7538429a2"
  ],
  "author": "Stephan B√∂kelmann",
  "first_used": "2025-04-02",
  "keywords": ["Assembler", "C", "Object Files", "Comparison"]
}
--->

# Comparing Object Files from GAS and GCC

## 1) Introduction  
> üîç Understanding the difference between hand-written assembly and compiler-generated code gives you insight into how programming abstractions are translated into machine-level instructions.

When writing programs in assembly language using GAS (the GNU Assembler), you directly describe every instruction the CPU is supposed to execute. This means you ‚Äî the human ‚Äî are fully responsible for register allocation, memory access, function call conventions, and dealing with system calls or external symbols. Every `mov`, every `call`, every `push` must be explicitly defined.

In contrast, a C compiler such as GCC takes care of most of these decisions for you. It parses your high-level source code and translates it into assembly instructions based on architecture-specific rules, optimization passes, and internal data representations. The output can be surprisingly complex, but it reveals the "cost" and "shape" of your abstractions.

Both approaches ‚Äî manual assembly and compiled C ‚Äî ultimately produce the same kind of intermediate result: an **object file**. This is a binary file that contains machine instructions, metadata about functions and variables (symbols), and section headers indicating where instructions and data are stored. Object files produced by `as` and `gcc -c` can be compared to understand what the compiler *adds*, *assumes*, and *organizes* for you.

When you compare `.o` files generated by GCC and GAS, you're comparing:
- Human intent versus machine-optimized abstraction
- Explicit versus inferred behavior
- Manual versus automatic alignment, prologues, and symbol decorations

This comparison is critical to understanding what compilers *really do*, and where the boundaries lie between **control** and **convenience**. You'll see, for instance:
- How symbol names are decorated (`_start`, `.L2`, etc.)
- How calling conventions are applied (stack frames, register usage)
- What metadata GCC inserts for use by debuggers and linkers

> ‚ö†Ô∏è Remember: just because the object files are different, doesn't mean they behave differently. The goal of a compiler is not to make the same file you would ‚Äî it's to make a file that behaves *as if* you wrote it.

By using tools like `objdump`, `readelf`, and `nm`, you can dissect these object files and gain a much deeper understanding of how modern toolchains work. This will also prepare you for debugging, reverse engineering, writing linker scripts, or working in environments where you need to mix C and assembly (e.g. OS kernels, embedded systems, or performance-critical code).


### 1.1) Further Readings and Other Sources
- [Using `objdump` and `readelf`](https://linux.die.net/man/1/objdump)
- [Eli Bendersky: Dissecting ELF files](https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries)
- [Reverse Engineering Basics](https://www.youtube.com/watch?v=0j0CAZyzKqo)

## 2) Tasks
1. **Create Object Files**: Compile a simple C file with `gcc -c generated.c` and assemble a `.s` file with `as -o hand.o hand.s`:
```C
int add(int a, int b) {
    return a + b;
}
```
```asm
    .globl add
    .text
add:
    mov %rdi, %rax
    add %rsi, %rax
    ret
```
2. **Compare Output**: Use `objdump -d` on both `generated.o` and `hand.o` and redirect it into a file. Use `vimdiff <file1> <file2>` to inspect the differences.
3. **Header Info**: Use `readelf -h` and `readelf -s` to compare symbol tables and headers.
4. **Section Sizes**: Inspect the sizes of both `size generated.o` and `size hand.o`. Observe the `.section` size.
5. **Try Linking**: Attempt to link both into a binary using `gcc`.
```C
#include <stdio.h>

extern int add(int a, int b);  // Declaration of the external function

int main() {
    int result = add(2, 3);
    printf("2 + 3 = %d\n", result);
    return 0;
}
```
```bash
gcc -c main.c -o main.o
gcc main.o generated.o -o c_program
gcc main.o hand.o -o as_program
```

<details>
  <summary>Using ld to link</summary>

  You could also use `ld` directly to link these files, but it requires significantly more setup.  
  In addition to your object files, you would need to explicitly provide:

  - The path to the C standard library (to resolve symbols like `printf`)
  - Startup code (such as `crt1.o`) that defines `_start` and correctly calls your `main()` function

  Unlike `gcc`, `ld` does not automatically include these components ‚Äî you're responsible for supplying everything required to build a functional executable.
</details>


## 3) Questions
1. What sections are created in both object files?
2. How does the symbol table differ between C and GAS compiled code?
3. Why might your hand-written code be smaller?
4. What kind of metadata does the C compiler add that GAS does not?
5. How would inline assembly in C affect the object file?

## 4) Advice
Don't worry if the object files look very different at first ‚Äî compilers insert metadata, alignment, and use calling conventions you might not be aware of. Focus on one function and trace its transformation from source to machine code.
